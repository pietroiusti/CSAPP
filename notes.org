* Representing and Manipulation information
- Converting between binary and hexadecimal is straightforward, since
  it can be performed one hexadecimal digit at a time.

- Coverting between decimal and hexadecimal representations requires
  using multiplication or division to handle the general case.

- Every computer has a /word size/, indicating the nominal size of
  pointer data.
  - Since a virtual address is encoded by such a word, the most
    important system parameter determined by the word size is the
    maximum size of the virtual address space. (A machine with a w-bit
    word size will have a virtual addresses ranging from 0 to
    (2^w)-1.)

- There are ``typical'' sizes of C data types, but there might be
  differet in different machines. To avoid problems, ISO C99
  introduces ~int32_t~ and ~int64_t~.

  [[./figures/typical_c_sizes.png]]

- Two conventions for ordering bytes representing an object: /little
  endian/, /big endian/.
  - Usually one is not concerned with this. But, one is, for example
    in the context of:
    - networking;
    - inspecting machine-level programs;
    - circumventing the normal type system, by using a /cast/ or a
      /union/.

- A string in C is encoded by an array of characters terminated by the
  null (having value 0) character.

- ``A fundamental concept of computer systems is that a program, from
  the perspective of the machine, is simply a sequence of bytes''.

** Practice problems
*** 2.1
- A. Ox39A7F8
  In binary: 0011 1001 1010 0111 1111 1000

- B. 1100 1001 0111 1011
  In hex: 0xC97B

- C. OxD5E4C
  In binary: 1101 0101 1110 0100 1100

- D. 10 0110 1110 0111 1011 0101
  In hex: 0x26E7B5

*** 2.2
Fill in the blank entries in the following table, giving the decimal
and hexadecimal representations of different powers of 2:

|  n | 2^n (decimal) | 2^n (hexadecimal) |
|----+---------------+-------------------|
|  9 |           512 |             0x200 |
|----+---------------+-------------------|
| 19 |        524288 |           0x80000 |
|----+---------------+-------------------|
| 14 |         16384 |            0x4000 |
|----+---------------+-------------------|
| 16 |         65536 |           0x10000 |
|----+---------------+-------------------|
| 17 |        131072 |           0x20000 |
|----+---------------+-------------------|
|  4 |            32 |              0x20 |
|----+---------------+-------------------|
|  7 |           128 |              0x80 |

*** 2.3
A single byte can be represented by 2 hexadecimal digits. Fill in the
missing entries in the following table, giving the decimal, binary,
and hexadecimal values of different byte patterns:

| Decimal | Binary    | Hexadecimal |
|---------+-----------+-------------|
|       0 | 0000 0000 |        0x00 |
|---------+-----------+-------------|
|     167 | 10100010  |        0xA7 |
|---------+-----------+-------------|
|      62 | 111110    |        0x3E |
|---------+-----------+-------------|
|     188 | 10111100  |        0xBC |
|---------+-----------+-------------|
|      55 | 00110111  |        0x37 |
|---------+-----------+-------------|
|     136 | 1000 1000 |        0x88 |
|---------+-----------+-------------|
|     243 | 11110011  |        0xF3 |
|---------+-----------+-------------|
|      82 | 0101 0010 |        0x52 |
|---------+-----------+-------------|
|     172 | 1010 1100 |        0xAC |
|---------+-----------+-------------|
|     231 | 1110 0111 |        0xE7 |
|---------+-----------+-------------|

*** 2.4
Without converting the numbers to decimal or binary, try to solve the
following arithmetic problems, giving the answers in
hexadecimal. Hint: Just modify the methods you use for performing
decimal addition and subtraction to use base 16.

A. 0x503c + 0x8 = 0x5044

B. 0x503c - 0x40 = 0x4ffc

C. 0x503c + 64 = 0x503c + 0x40 = 507c

D. 0x50ea - 0x503c = 0xAE

*** 2.5
Consider the following three calls to ~show_bytes~:

#+begin_src C
  int val = 0x87654321;
  byte_pointer valp = (byte_pointer) &val;
  show_bytes(valp , 1);
  show_bytes(valp , 2);
  show_bytes(valp , 3);
#+end_src

Indicate the values that will be printed by each call on a
little-endian machine and on a big-endian machine:

|   | Little endiand | Big endian |
|---+----------------+------------|
| A |             21 |         87 |
|---+----------------+------------|
| B |           2143 |       8765 |
|---+----------------+------------|
| C |         214365 |     876543 |

*** 2.7
#+begin_quote
What would be printed as a result of the following call to show_bytes?

#+begin_src C
  const char *s = "abcdef";
  show_bytes((byte_pointer) s, strlen(s));
#+end_src

#+RESULTS:

Note that letters 'a ' through 'z' have ASCII codes 0x61 through 0x7A.
#+end_quote

61 62 63 64 65 66.

*** 2.8
a: [01101001]
b: [01010101]

~a: [10010110]
~b: [10101010]

a & b: [01000001]
a | b: [01111101]
a ^ b: [00111100]

*** 2.18
A: 0x2e0 = 0000001011100000 = 736.

B: 0x58 = 0000000001011000 = 88.

C: 0x28 = 0000000000101000 = 40.

D: 0x30 = 0000000000110000 = 48.

E: 0x78 = 0000000001111000 = 120.

F: 0x88 = 0000000010001000 = 136

G: 0x1f8 = 0000000111111000 = 504.

H: 0xC0 = 0000000011000000 = 192.

I: 0x48 = 0000000001001000 = 72.

*** 2.19
* Bomb Lab Recitation
- defusing your bomb
  - ~objdump -t bomb~ examines the symbole table
  - ~objdump -d bomb~ disassembles all bomb code
  - ~strings bombs~ prints all printables strings
  - ~gdb bomb~ will open the GNU Debugger
    - ~help~
    - ~break~
    - ~disassemble~
    - ~info registers~
    - ~print~ (~/x~ or ~/d~) ~$rsp~
    - ~stepi~
    - ~step~
    - ~nexti~
    - ~x~ (examine)
      - ~x/8a 0x15213~
      - ~x/4wd 0xdeadbeef~
    - ~help stack~
    - ~backtrace~


* Machine-Level Representation of Programs
#+begin_src C
  long mult2(long , long);

  void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
  }
#+end_src

We can run ~gcc -Og -S mstore.c~ to generate the assembly code. The
file ~mstore.s~ with the following content is generated:

#+begin_src asm
          .file	"mstore.c"
          .text
          .globl	multstore
          .type	multstore, @function
  multstore:
          .LFB0:
          .cfi_startproc
          pushq	%rbx
          .cfi_def_cfa_offset 16
          .cfi_offset 3, -16
          movq	%rdx, %rbx
          call	mult2@PLT
          movq	%rax, (%rbx)
          popq	%rbx
          .cfi_def_cfa_offset 8
          ret
          .cfi_endproc
          .LFE0:
          .size	multstore, .-multstore
          .ident	"GCC: (GNU) 13.2.1 20230801"
          .section	.note.GNU-stack,"",@progbits
#+end_src

We can use the -c option to compile and assemble: ~gcc -Og -c
mstore.c~. Now the file ~mstore.o~ is generate too. This file is 1,368
bytes and contains the 14-byt sequence with the following hexadecimal
representation:
#+begin_src
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
#+end_src

We can use ~objdump~ to disassemble: ~objdump -d mstore.o~. This is
the output:

#+begin_src
mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	call   9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	ret
#+end_src

The last thing to do to get the actual executable code is running a
linker. The linker must be run on the set of object-code files, one of
which must contain a ~main~ function.

Let's then create a ~main.c~ file:

#+begin_src C
  #include <stdio.h>

  void multstore(long, long, long *);

  int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
  }

  long mult2(long a, long b) {
    long s = a * b;
    return s;
  }
#+end_src

We can generate an executable named ~prog~ with: ~gcc -Og -o prog
main.c mstore.c~.

Let's also disassemble the file prog: ~objdump -d prog~...

** Procedures
- Mechanisms in procedures
  - (1) PASSING CONTROL
    - to beginning of procedure code
    - back to return point
  - (2) PASSING DATA
    - procedure arguments
    - return value
  - (3) MEMORY MANAGEMENT
    - Allocate during procedure execution
    - Deallocate upon return

We have to introduce the /stack/. The stack is a region of memory. It
grows toward lower addresses.

~%rsp~ contains the lowest stack address (the address of the element
at the ``top'' of the stack).

~%rip~ contains the next instruction to be executed.

~push~ and ~pop~ make use of the stack.

- (1) PASSING CONTROL
  - How does a ~call~ to a function works? How do we pass control to it?
    - i) We push onto the stack the address of where we have to return
      (the instruction following the call) when the function
      finishes. This means that we update the value of the %rsp, because
      the stack has grown.
    - ii) We set ~%rip~ to the beginning of the function which is being
      called
  - How does the returning a function work?
    - iii) when the function hits the ~ret~ instruction, ~%rip~ is set
      to the value we have previously stored in the stack, and the stack
      is freed of the stuff we have stored with respect to the function
      that just returned.

- (2) PASSING DATA
  - the first 6 arguments are passed in:
    | %rdi |
    |------|
    | %rsi |
    |------|
    | %rdx |
    |------|
    | %rcx |
    |------|
    | %r8  |
    |------|
    | %r9  |
  - The return value is in ~%rax~ (only for integers and pointers).
  - The other arguments (if any) are put on the stack.


# Let's assume (not very realistically) that we are in a context in
# which the value of ~%rsp~ is ~0x120~ and the value of ~%rip~ is
# ~0x400544~.


** Practice problems
*** 3.4
Assume variables ~sp~ and ~dp~ are declared with types

#+begin_src C
  src_t *sp;
  dest_t *dp;
#+end_src

where ~src_t~ and ~dest_t~ are data types declared with ~typedef~. We
wish to use the appropriate pair of data mvoement instructions to
implement the operation

#+begin_src C
  *dp = (dest_t) *sp;
#+end_src

Assume that the values of ~sp~ and ~dp~ are stored in registers ~%rdi~
and ~%rsi~, respectively. For each entry in the table, show the two
instructions that implement the specified data movement. The first
instruction in the sequence should read from memory, do the
appropriate conversion, and set the appropriate portion of register
~%rax~. The second instruction should then write the appropriate
portion of ~%rax~ to memory. In both cases, the portions may be
~%rax~, ~%eax~, ~%ax~, or ~%al~, and they may differ from one another.

Recall that when performing a cast that involves both a size change
and a change in ``signedness'' in C, the operation should change the
size first (Section 2.2.6).

| src_t | dest_t | Instruction       |
|-------+--------+-------------------|
| long  | long   | movq (%rdi), %rax |
|       |        | movq %rax, (%rsi) |

- Explanation:
  the C statement is this
  #+begin_src C
    *dp = *sp;
  #+end_src

  where dp and sp are defined as follows:

  #+begin_src C
    typedef long src_t;
    typedef long dest_t;

    src_t *sp;
    dest_t *dp;
  #+end_src

  The operation to perform (~*dp = *sp;~) is that of moving the data
  in memory at the address stored in ~sp~ into another location in
  memory; the location at the address store in ~dp~.

  The get the data in memory at the address stored in ~sp~ we can use
  ~(%rsi)~. ~%rsi~, by definition, is the register in which ~sp~ is
  stored. Wrapping into parenthesis means: the location in memory with
  the address stored in ~%rsi~.

  We cannot simply move the data from a location in memory into
  another location in memory. In fact we are told to use the register
  ~%rax~ as an intermediary step.

  The data we are moving is 8 bytes (a ``quad word'') so we can use
  ~movq~:

  #+begin_src asm
            movq (%rdi), %rax
  #+end_src

  With that, we have the moved 8 bytes from the source into one
  register. The next step consists in moving those bytes into another
  location in memory; that location by definition is at the address
  stored in %rsi.

  So, the second instruction is:

  #+begin_src asm
            movq %rax, (%rsi)
  #+end_src

| src_t | dest_t | Instruction         |
|-------+--------+---------------------|
| char  | int    | movsbl (%rdi), %eax |
|       |        | movl %eax, (%rsi)   |

Comment: in this case, we first need to convert the char into an
int. This means converting 1 byte (see the ~b~ in ~movsbl~) to 4 bytes
(see the ~l~ in ~movsbl~). Given that the value is signed, this
operation is performed by sign extension (see the ~s~ in ~movsbl~),
not by zero extension (~z~).

| src_t | dest_t   | Instruction         |
|-------+----------+---------------------|
| char  | unsigned | movsbl (%rdi), %eax |
|       |          | movl %eax, (%rsi)   |

Comment: the comment about the previous case applies here too.

| src_t         | dest_t | Instruction         |
|---------------+--------+---------------------|
| unsigned char | long   | movzbl (%rdi), %eax |
|               |        | movq %rax, (%rsi)   |

Comment: here we want to extend a unsigned char (one byte) to a long
(eight bytes). Given that it is an unsigned value, we use zero
extension, not sign extension. Then why ~movzbl (%rdi), %eax~ instead
of ~movzbq (%rdi), %rax~?

Here is what Authors say in Errata
(https://web.archive.org/web/20230813064349/http://csapp.cs.cmu.edu/3e/errata.html):

#+begin_quote
p. 184, (Clarification, not an erratum) Figure 3.5. Although there is
an instruction movzbq, the GCC compiler typically generates the
instruction movzbl for this purpose, relying on the property that an
instruction generating a 4-byte with a register as destination will
fill the upper 4 bytes of the register with zeros.  Posted
04/27/2018. Randal Bryant

(Clarification, not an erratum) p. 326, Solution to Problem 3.4,
seventh line of code. The GCC compiler generates the instruction
movzbl for this case, even though the goal is to extend the 1-byte
value to 8 bytes. See the note on Figure 3.5 (p. 184).  Posted
04/27/2018. Randal Bryant
#+end_quote

| src_t | dest_t | Instruction       |
|-------+--------+-------------------|
| int   | char   | movl (%rdi), %eax |
|       |        | movb %al, (%rsi)  |

Comment: here we first move the whole 4 bytes into the 4-byte portion
of %rax. Then we just store the the content of %al (the first byte of
%rax).

| src_t    | dest_t        | Instruction       |
|----------+---------------+-------------------|
| unsigned | unsigned char | movl (%rdi), %eax |
|          |               | movb %al, (%rsi)  |

Comment: none. Notice though that these are the same instructions as
before.

| src_t | dest_t | Instruction        |
|-------+--------+--------------------|
| char  | short  | movsbw (%rdi), %ax |
|       |        | movw %ax, (%rsi)   |

Comment: we want to upgrade a char (one byte) (~b~) to a short (two
bytes) (~w~). Since it's a signed value we use sign extension (~s~).
*** 3.6
Suppose register %rax holds value x and %rcx holds value y. Fill in
the table below with formulas indicating the value that will be stored
in %rdx for each of the given assembly-code instructions:

| Instruction               | Result     |
|---------------------------+------------|
| leaq 6(%rax), %rdx        | 6 + x      |
|---------------------------+------------|
| leaq (%rax,%rcx), %rdx    | x + y      |
|---------------------------+------------|
| leaq (%rax,%rcx,4), %rdx  | x + 4y     |
|---------------------------+------------|
| leaq 7(%rax,%rax,8), %rdx | 7 + 9x     |
|---------------------------+------------|
| leaq 0xA(,%rcx,4), %rdx   | 10 + 4y    |
|---------------------------+------------|
| leaq 9(%rax,%rcx,2), %rdx | 9 + x + 2y |
*** 3.16
*Problem*:

#+begin_quote
When given the C code

#+begin_src C
  void cond (long a, long *p) {
    if (p && a > *p) {
      *p = a;
    }
  }
#+end_src

GCC generates the following assembly code:

#+begin_src asm
cond:
        testq   %rsi, %rsi
        je      .L1
        cmpq    %rdi, (%rsi)
        jge     .L1
        movq    %rdi, (%rsi)
.L1:
        ret
#+end_src

A. Write a goto version in C that performs the same computation and
mimics the control flow of the assembly code, in the style shown in
Figure 3.16(b).  You might find it helpful to first annotate the
assembly code as we have done in our examples.

B. Explain why the assembly code contains two conditional branches,
even though the C code has only one if statement.

#+end_quote

*Answer*:

#+begin_src C

  void cond(long a, long *p) {

    if (p == 0) {
      goto done;
    }

    if (*p >= a) {
      goto done;
    }

    *p = a;

    done:
      return;
  }

#+end_src
*** 3.17
*Problem*:

#+begin_quote
An alternate rule for translating ~if~ statements into goto code is as
follows:

#+begin_src C
  t = test-expr;
  if (t)
    goto true/;
  else-statement;
  goto done;
  true:
      then-statement
  done:
#+end_src
#+end_quote

A. Rewrite the goto version of ~absdiff_se~ based on this alternate rule.

B. Can you think of any reasons for choosing one rule over the other?

*Answer*:

#+begin_src C
  long gotodiff_se_alt(long x, long y) {
    long result;
    if (x < y)
      goto true;
    ge_cnt++;
    result = x - y;
    return result;
    true:
      lt_cnt++;
      result = y - x;
      return result;
  }
#+end_src
* Linking (lecture 14, 2015)
(https://scs.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=0aef84fc-a53b-49c6-bb43-14cb2b175249)

- We are going to see how our programs interact with software (as
  opposed to how they interact with hardware, a topic which have
  partly investigated already), in particular system software.

- We are going to starting this investigation by studying a process
  called linking, which is *how the system builds your program*.

- Example C program:

  #+begin_src C
    // main.c

    int sum (int *a, int n);

    int array[2] = {1, 2};

    int main()
    {
        int val = sum(array, 2);
        return val;
    }
  #+end_src

  #+begin_src C
    // sum.c

    int sum(int *a, int n)
    {
        int i, su = 0;

        for (i = 0; i < n; i++) {
    	s += a[i];
        }
        return s;
    }
  #+end_src

- Programs are translated and linked using a compiler driver:
  - ~linux> gcc -Og -o prog main.c sum.c~
  - ~linux> ./prog~

    main.c                       sum.c             Source files
      |                            |
      V                            V
   ----------------             ----------------
   | Translators  |             | Translators  |
   | (cpp,cc1,as) |             | (cpp,cc1,as) |
   ----------------             ----------------
          |                             |
          V                             V          Separately compiled
        main.o                        sum.o        /relocatable/ object files
          |                             |
          V                             V
        ----------------------------------
        |            linker              |
        ----------------------------------
                        |
                        V
                       prog               Fully linked /executable/ object file
                                          (contains code and data for all functions
                                          defined in main.c and sum.c)

- *Why Linkers?*
  - *1. Modularity*
    - Program can be written as a collection of smaller source files,
      rather than one monolithic mass.
    - Can build libraries of common functions (more on this later)
      - e.g., Math library, standard C libary.

  - *2. Efficiency*
    - Time: Separate compilation
      - Change one source file, compie, and then relink
      - No need to recompile other source files.
    - Space: Libraries
      - Common functions can be aggregated into a single file...
      - Yet executable files and running memory images contain only
        code for the functions they actually use.

- *What Do Linkers Do?* There are two main tasks that a linker
  performs.
  - *Step 1: Symbol resolution*
    - Programs define and reference /symbols/ (global variables and
      functions):
      - ~void swap() {...} /* define symbol swap */~
      - ~swap();           /* reference symbol swap */~
      - ~int *xp = &x;     /* define symbol xp, reference x */~
    - Symbol definitions are stored in object file (by assembler) in
      /symbol/ table.
      - Symbol table is an array of /structs/.
      - Each entry includes name, size, and location of symbol.

    - *During symbol resolution step, the linker associates each
      symbol reference with exactly one symbol definition.*
  - *Step 2: Relocation*
    - Merges separate code and data sections into single sections
    - Relocates symbol from their relative locations in the .o files
      to their final absolute memory locations in the executable.
    - Updates all references to these symboles to reflect their new
      position.

- Before looking at these two steps in more detail, let's define a few
  things.

- Three Kinds of Object Files (Modules)
  - Relocatable object file (.o file)
    - Contains code and data in a form that can be combined with other
      relocatable object files to form executable object file.
      - each .o file is produced from exactly one source (.c) file.
  - Executable object file (a.out file)
    - Contains code and data in a form that can be copied directly
      into memory and then executed.
  - Shared object file (.so file)
    - Special type of relocatable object file that can be loaded inot
      memory and linked dynamically, at either loda time or run-time.
    - Called /Dynamic Link Libraries/ (DLLs) by Windows.

- Object Modules come in a standard format called the ELF format.

- One unified format for
  - Relocatable object files (.o),
  - Executable object files (a.out),
  - Shared object files (.so)

- Generic name: ELF binaries

- While these ELF binaries are binaries, they are very
  structured. They are broken up into sections.

  - *Elf header*
    - words size, byte ordering, file type (.o, exec, .so), machine
      type, etc.
  - *Segment header table*
    - Page size, virtual address memory segments (sections), segment
      sizes
  - *.text section*
    - Code
  - *.rodata section*
    - Read only data: jump tables, ...
  - *.data section*
    - Initialized global variables
  - *.bss section*
    - Uninitialized global variables
    - ``Block Started by Symbol''
    - ``Better Save space''
    - Has section header but occupies no space
  - *.symtab section*
    - Symbol table
    - Procedure and static variable names
    - Section names and locations
  - *.rel.text section*
    - relocation info for .text section
    - Addresses of instructions that will need to be modified in the
      executable
    - Instructions for modifying
  - *.rel.data section*
    - Relocations info for .data section
    - Addresses of point data that will need to be modified in the
      merged executable
  - *.debug section*
    - Info for symbolic debugging (gcc -g)
  - *Section header table*
    - Offset and sizes of each section

      #+begin_src
                           +-- +------------------------------+
                           |   |      ELF header              |
                           |   +------------------------------+
                           |   |   Segment header table       |
                           |   | (required for executables)   |
                           |   +------------------------------+
                           |   |      .text                   |
                           |   +------------------------------+
                           |   |      .rodata                 |
                           |   +------------------------------+
                           |   |      .data                   |
                           |   +------------------------------+
                           |   |      .bss                    |
                           |   +------------------------------+
                 Sections <|   |      .symtab                 |
                           |   +------------------------------+
                           |   |      .rel.text               |
                           |   +------------------------------+
                           |   |      .rel.data               |
                           |   +------------------------------+
                           |   |      .debug                  |
                           |   +------------------------------+
                           |   |      .line                   |
                           |   +------------------------------+
                           |   |      .strtab                 |
              Describes    +-- +------------------------------+
              object file <|   |      Section header table    |
              sections     +-- +------------------------------+
    #+end_src

- To a linker there are three different kinds of *symbols*
  - Global symbols
    - Symbols defined by module /m/ that can be referenced by other
      modules.
    - E.g.: non-static C functions and non-static global variables.
  - External symbols
    - Global symbols that are referenced by module /m/ but defined by
      some other module
  - Local symbols
    - Symbols that are defined and referenced exclusively by module
      /m/.
    - E.g.: C functions and global variables defined with the static
      attribute.
    - *Local linker symbols are not local program variables*

- (The `static` C attribute is used when we want to make a function of
  our module /private/. That the way we get abstraction and
  information hiding in C, and expose only those functions and that
  data that we want to expose.)

- Let's look in detail at how symbol resolution works.

  [[./img/slide14.jpg]]

- Local non-static C variables vs. local static C variables
  - local non-static C variables: stored on the stack
  - local static C variables: stored in either .bss, or .data

- Consider:
  #+begin_src C
    int f()
    {
        static int x = 0;
        return x;
    }

    int g()
    {
        static int x = 1;
        return x;
    }
  #+end_src
  The compiler allocates space in .data for each definition of x.

  It creates local symboles in the symbol table with unique names,
  e.g., x.1 and x.2.

  - During symbole resolution, the linker associates each symbol
    reference to exactly one unique symbol definition. How does it do
    that if there are multiple symbol definitions across all the
    modules?
    - Program symbols are either strong or weak
      - Strong: procedures and initialized globals
      - Weak: uninitialized globals
      - Ex.:
        #+begin_src C
          // p1.c

          int foo = 5; // strong

          p1() { // strong
          }
        #+end_src
        #+begin_src C
          // p2.c

          int foo; // weak

          p1() { // strong
          }
        #+end_src
    - Linker follow these rules:
      - *Rule 1*: Multiple strong symboles are not allowed
        - Each item can be defined only once
        - Otherwise: liker error
      - *Rule 2*: Given a strong symbol and multiple weak symboles,
        choose the strong symbol
        - Refernces to the weak symbol resolve to the strong symbol
      - *Rule 3*:
        - Can override this with gcc -fno-common

- If you are not aware of this stuff you can run into serious,
  perplexing and confounding, problems. Linker error are usually the
  most difficult to debug because people don't usually know what is
  going on inside the linkers.

  [[./img/slide18.jpg]]


- *Avoid global variables if you can*

- Otherwise
  - Use ~static~ if you can (because that will limit its scope to the
    module it is declared in)
  - Initialize if you define a global variable (so that you will
    discover if you have multiple initialized global symbols with the
    same name)
  - Use ~extern~ if you reference an external global variable (it's
    good practice to tell the compiler)

- Once symbol resolution is done, the linker has associated each
  symbol reference to a symbol definition.

  After that, the linker has to take all those relocatable object
  files and merge them to create one big executable.

- Relocation in detail (Step 2):

  main.o contains code and initialized data.

  main.o
  |--------------------|
  | main()             |  .text
  |--------------------|
  | int array[2]={1,2} |  .data
  |--------------------|

  sum.o just has code.

  sum.o:
  |-------|
  | sum() |  .text
  |-------|

  And there is also system code that runs before and after your
  code. When your program runs is gonna actually executing startup
  code from libc whose last action is calling main passing arc and
  argv. When your program's main function returns, it returns to that
  startup code (which then does an exit). That code consists of data
  and code as well.

  |-------------|
  | System code |  .text
  |-------------|
  | System data |  .data
  |-------------|

  When the linker relocates these files, it takes all the code from
  the .text sections of each of the module and puts it together
  contiguously (in some order that it determines) in the .text section
  of the executable object file.

  And then it does the same with the .data sections.

  The act of reloacting this object files requires the linker to
  figure out where it is going to actually store these different
  symbols when this program gets loaded.

  It has to pick an address for main that function will start at. Some
  absolute address. And the same for sum, and the data...

  The problem is that when this code is compiled, the compiler does
  not know which addresses the linker is gonna pick.

  So the compiler creates some reminders to the linker called
  *relocation entries*, which are stored in the relocation section of
  the object files. The *relocation entries* tell the linker that
  there is a reference to a symbol that's gonna have to be patched up
  when the code is relocated and merged into the executable.

- See ~objdump -r -d main.o~...

  #+begin_src bash
    [linux]$ gcc -c -Og main.c

    [linux]$ objdump -d -r main.o # disassemble and print relocation entries of main.o

    main.o:     file format elf64-x86-64


    Disassembly of section .text:

    0000000000000000 <main>:
    0:	48 83 ec 08          	sub    $0x8,%rsp
    4:	be 02 00 00 00       	mov    $0x2,%esi
    9:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 10 <main+0x10>
    c: R_X86_64_PC32	array-0x4
    10:	e8 00 00 00 00       	call   15 <main+0x15>
    11: R_X86_64_PLT32	sum-0x4
    15:	48 83 c4 08          	add    $0x8,%rsp
    19:	c3                   	ret
  #+end_src

- See ~objdump -dx prog~. When can see that the linker has patched the
  right place with the addresses.
  #+begin_src asm
    # ....
    0000000000001119 <main>:
        1119:	48 83 ec 08          	sub    $0x8,%rsp
        111d:	be 02 00 00 00       	mov    $0x2,%esi
        1122:	48 8d 3d e7 2e 00 00 	lea    0x2ee7(%rip),%rdi        # 4010 <array>
        1129:	e8 12 00 00 00       	call   1140 <sum>
        112e:	48 83 c4 08          	add    $0x8,%rsp
        1132:	c3                   	ret
        1133:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
        113a:	00 00 00
        113d:	0f 1f 00             	nopl   (%rax)

    0000000000001140 <sum>:
        1140:	ba 00 00 00 00       	mov    $0x0,%edx
        1145:	b8 00 00 00 00       	mov    $0x0,%eax
        114a:	eb 0d                	jmp    1159 <sum+0x19>
        114c:	0f 1f 40 00          	nopl   0x0(%rax)
        1150:	48 63 c8             	movslq %eax,%rcx
        1153:	03 14 8f             	add    (%rdi,%rcx,4),%edx
        1156:	83 c0 01             	add    $0x1,%eax
        1159:	39 f0                	cmp    %esi,%eax
        115b:	7c f3                	jl     1150 <sum+0x10>
        115d:	89 d0                	mov    %edx,%eax
        115f:	c3                   	ret
     #...
  #+end_src

- The compiler does all the smart stuff (it computes the relocation
  entries), the linker just does what it is told to do.

- Once the linker has created an object file, the data and code of
  that object file can be loaded into memory without futher
  modifications.

- This is the address space that every linux program sees:

  #+begin_src 
              |-------------------------|^  Memory
              |                         ||  invisible to
              | Kernel Virtual memory   ||  user code
              |-------------------------|
              | User stack              |
              | (created at runtime)    |
              |-------------------------|<--- %rsp
              |           |             |     (stack
              |           V             |      pointer)
              |                         |
              |-------------------------|
              | Memory-mapped region    |
              | for shared libraries    |
              |-------------------------|
              |                         |
              |           ^             |
              |           |             |
              |-------------------------|<--- brk
              | Run-time heap           |
              | (created by malloc)     |
              |-------------------------| ---
              | Read/write data segment |   |   Loaded
              | (.data, .bss)           |   |   from
              |-------------------------|   |-> the
              | Read-only code segment  |   |   executable
              | (.init, .text, .rodata) |   |   file
    0x400000  |-------------------------| ---
              | Unused                  |
           0  |-------------------------|
  #+end_src

  - We are drawing addresses starting from 0 and increasing as we go
    up.

  - Every program is loaded at the same address (0x400000).

  - The code comes directly from the object file.

  - The data comes directly from the object file.

  - And it is followed by a run-time heap (which grows upwards), which
    is created and managed by ~malloc~.

  - The stack (which grows down) is at the very top of the visible
    memory that's available to application programs. The stack is
    created and managed at runtime.

  - The memory above that is restricted to the kernel. If you try to
    access those memory locations, you'll get a segfault.

  - Somewhere in the huge gap between the stack and the heap, there is
    a region for shared libraries. ~.so~ files all get loaded there.

  - The top of the heap is indicated by the global variable ~brk~,
    which is maintained by the kernel.

  - The top of the stack is maintained by the general purpose register
    ~%rsp~.

  - (This is a little of a simplification. If you actually look at the
    addresses returned by ~malloc~, there are actually two
    heaps... (one for large object which grows down, and one for small
    object --- the one depicted in our drawing --- which grows
    upwards.)

- So, one of the real advantages of linking is that it allows us to
  create libraries of things. As programmers, we always want to create
  abstractions and the present those abstractions to users. That is,
  define apis, package up those apis, and make them availabe to other
  programmers.

- How can we actually do that?

  - Option 1. Given what we have learnt so far you can just take all
    the functions and put them all in a single big C file. Programmers
    can then link their program tot hat c file if they want to use
    those functions.
    - space and time inefficient.

  - Option 2. Another option would be putting each function in a
    separate file, and then compile and link them all together.
    - More efficient, but burdensome on the programmer
    
- OLD-FASHION SOLUTION: *Static Libraries*.
  - This is the first idea the developers of unix came up with. The
    idea is creating an archive called the ~.a file~, which is just a
    collection of .o files, where each .o file contains a function.
    Basically you create a bunch of .o files, and then you use a
    program called ``archiver'' (ar) to put those .o files together
    in a big file called ``archive'' with a toc at the beginning which
    tells you the offset of each one of the .o files.  
  - You pass that archive to the linker. The linker will link only
    those .o file that are actually refenced. You can have a huge
    archive, but if you only call printf, then the only .o file you
    get is printf.o.

- Creating Static Libraries:

           atoi.c             printf.c             random.c       
             |                   |                    |
             V                   V                    V
        --------------      --------------       --------------
        | translator |      | translator |  ...  | translator |
        --------------      --------------       --------------
               |                  |                    |
               |                  |                    |
               \---------         |          ---------/
                        |         |          |
                        V         V          V
                     ---------------------------    unix> ar rs libc.a \
                     |      Archiver (ar)      |      atoi.o printf.o ... random.o
                     ---------------------------
                                  |
                                  V      C Standard library
                               libc.a

- Archiver allows incremental updates

- libc.a (the C standard library) is about 1496 object files (4.6 MB)

- libm.a (the C math library) is about 444 object files (2 MB)

- ~[linux]$ ar -t /usr/lib/libc.a | sort~:
  #+begin_src bash
    a64l.o
    abort.o
    abs.o
    accept4.o
    accept.o
    access.o
    acct.o
    addmul_1.o
    add_n.o
    adjtime.o
    ...
  #+end_src

- the convention has it that a library starts with `lib'.

- Linking with static libaries:

  [[./img/slide29.jpg]]


- This liking is done at compile time.

- When using static libraries, the linker scans all .o files and .a
  files in the command line order.

- During the scan, it keeps a list of the current unresolved
  references.

- As each new .o or .a file is encounterd, the linker tries to resolve
  each unresolved references in the list against the symbols defined
  in the .o or .a file.

- If any entries in the unresolved list at end of scan, then error.

- Problem
  - Command line order matters!
  - Moral: put libraries at the end of the command line.
    #+begin_src bash
      [unix]$ gcc -L. libtest.o -lmine
      [unix]$ gcc -L. -lmine libtest.o 
      libtest.o: In function `main':
      libtest.o(.text+0x4): undefined reference to `libfun'
    #+end_src

- MODERN SOLUTION: *Shared Libraries*

- The reason there are these new sorts of libaries is that static
  libraries have some disadvantages.

- Importantly, for example, any program that uses ~printf~ has to have
  a copy of ~printf~ (and analogously for other functions)

- With shared libraries, object files that contain code and data are
  loaded and linked into an application /dynamically/, at either
  /load-time/ or /run-time/.
    
- Also called: dynamically link libraries, DLLs, .so files

- Dynamic linking can occur when executable is first loaded and run
  (load-time linking)

- Dynamic linking can also occur after the program has begun (run-time
  linking)

- Shared libraries routines can be shared by multiple processes. 

- Dynamic linking at load time
  - a shared library can be created using ~gcc~ 
  - the linker won't actually copy in the executable the functions
    contained in the library. It will simply make a note in the symbol
    table that the references to those function will need to be
    resolved when the program is loaded.
  - You can't take an executable file that was dynamically linked and
    load it directly: the loader (execve) takes the executable and the
    .so files that the program needs and call the dynamic linker
    (ld-linux.so) so that the executable in memory is fully linked.

- Dynamic linking at run time
  - You can use the ~dlopen~ interface which is present in libc
  - This is a very powerful technique

- Library interpositioning: powerful linking technique that allows
  programmer to intercept calls to arbitrary functions

- Interpositioning can occur at:
  - Compile time
  - Link time
  - Load/run time

* Linking
What is linking?

It consists in collecting/combining code and data into a single file.

The single file can be /loaded/ in memory and executed.

Linking can happen at different times:
- compile time (static linking);
- load time (dynamic linking);
- run time (dynamic linking);

Why are linkers important? Because they enable /separate compilation/.

Most compilation systems provide a /compiler driver/ which takes care
of preprocessing, compiling, assembling, and linking. GCC is one of
such drivers.

#+begin_src bash
  $ gcc -Og prog main.c sum.c
#+end_src

You can run ~gcc~ using the ~-v~ options to see the steps ~gcc~ takes.
** Static linking

- A static linker takes a collection of relocatable object files and
  command line arguments.

- The output of the a static linker is a ``fully linked executable
  object file that can be loaded an run''.

- *What does a relocatable file consist of?* It consists of ``code and
  data sections, where each section is a contiguous sequence of
  bytes.''  There is a section, for example, for instructions, and
  another section for initialized global variables, and another
  section for uninitialized variables.

- *What main tasks does a linker perform?*
  - Symbol resolution: association of each symbol /reference/ with
    exactly one symbole /definition/.
  - Relocation: ``compilers and assemblers generate code and data
    sections that start at address 0. The linker relocates...''. That
    is it assign a memory location to each symbol definition and
    changes all the refereces to the symbol so that they point to that
    memory location. In order to relocate, the linker uses
    instructions (called /relocation entries/) that have been
    generated by the assembler.

- Remember that object files are merely collections of blocks of bytes
  and that the compiler and the assembler have done most of the
  work...
** Object files
- There are three types of object files:
  - Relocatable object file :: ...

  - Executable object file :: ...

  - Shared object file :: a special type of relocatable object file that
    can be loaded into memory and linked /dynamically/ (either at load
    time or at run time).

- Object files are organized according to specific object file
  formats.
  - Windows: Portable Executable (PE);
  - Mac OS-X: Mach-O;
  - x86-64 Linux: Executable and Linkable Format (ELF).
** Relocatable Object Files

#+begin_src
                       +-- +------------------------------+
                       |   |      ELF header              |
                       |   +------------------------------+
                       |   |      .text                   |
                       |   +------------------------------+
                       |   |      .rodata                 |
                       |   +------------------------------+
                       |   |      .data                   |
                       |   +------------------------------+
                       |   |      .bss                    |
                       |   +------------------------------+
             Sections <|   |      .symtab                 |
                       |   +------------------------------+
                       |   |      .rel.text               |
                       |   +------------------------------+
                       |   |      .rel.data               |
                       |   +------------------------------+
                       |   |      .debug                  |
                       |   +------------------------------+
                       |   |      .line                   |
                       |   +------------------------------+
                       |   |      .strtab                 |
          Describes    +-- +------------------------------+
          object file <|   |      Section header table    |
          sections     +-- +------------------------------+
#+end_src

- ELF header: ...
- Section header table: ...
- sections: ...

** Symbols and Symbol Tables
- Each relocatable module, /m/[fn::Modules? Authors say:
  ``Technically, an /object module/ is a sequence of bytes, and an
  /object file/ is an object module stored on a disk in a
  file. However, we will use these terms interchangeably''.], has a
  symbol table.

- The symbole table contains information about the symbols that are
  defined and referenced by /m/.

- There are three kinds of symbols (in the context of a linker):
  - Global linker symbols :: they are defined by /m/ and can be
    referenced by other modules. They correspond to nonstatic C
    functions and global variables.
  - Externals :: they are referenced by /m/ but defined in some other
    module. They correspond to nonstatic C functions and global
    variables defined in other modules.
  - Local linker symbols :: they are defined and referenced exclusively by
    /m/. They correspond to static C function and global variable that
    are defined with the ~static~ attribute. They are visible anywhere
    within /m/, but cannot be referenced by other modules.


- Local linker symbols are not the same as local program
  variables. Local nonstatic program variables do not appear in the
  symbol table in ~.symtab~. Local nonstatic program variables are
  managed at run time on the stack. They are business of the linker.

- Local procedures variables that are defined with ~static~ are not
  managed on the stack. The compiler allocates spaec in ~.data~ or
  ~.bss~ for each definition and dreates a local linker symbol in the
  table with a unique name.

  For example:
  #+begin_src C
    int f()
    {
      static int x = 0;
      return x;
    }

    int g()
    {
      static int x = 1;
      return x;
    }
  #+end_src

** Symbol Resolution
- strong vs weak symbols
* Virtual memory
** Practice problems
*** 9.1
#+begin_src
| Number of virtual | Number of virtual | Largest possible |
|  address bits (n) | addresses (N)     | virtual address  |
|-------------------+-------------------+------------------|
|                 4 | 2^4 = 16          | 2^(4)-1 = 15     |
|-------------------+-------------------+------------------|
|                14 | 2^14 = 16K        | 2^(14)-1 = 16K-1 |
|-------------------+-------------------+------------------|
|                24 | 2^24 = 16M        | 2^(24) = 16M-1   |
|-------------------+-------------------+------------------|
|                46 | 2^46 = 64T        | 2^(46)-1 = 64T-1 |
|-------------------+-------------------+------------------|
|                54 | 2^54 = 16P        | 2^(54)-1 = 16P-1 |
#+end_src
* System-Level I/O
** Opening and closing files
- ~open~
** Reading and Writing files
- ~read~
- ~write~
- Authors also show several reading and writing function that they
  consider ``robust''. Some perform ``buffered'' operations.
** Reading File Metadata
- ~stat~
- ~fstat~
* Shell Lab Recitation
- Up to now, two mechanism for changing control flow:
  - jumps and branches
  - call and return

- Both react to changes in /program state/.
  - However, we also want to react to /system state/, in order to have
    a useful system.
    - data arriving from a disk or a network adapter
    - instruction divides by zero
    - user hits Ctrl-C
    - system timer expires

- Asynchronous Exceptions (aka Interrupts)
  - Caused by events external to the processor (you can't look at the
    assembly code and say "here there might be an asynchronous
    exception", because they just happen when the hardware decides to
    send them in.)

- Synchronous Exceptions
  - Caused by events that occur as a result of executing an
    instruction.
  - *Traps*
    - Intentional;
    - Ex: system calls (e.g., ~fork~, ~exec~), breakpoint traps (the
      way gdb handles breakpoints), special instructions;
    - Returns control to ``next'' instruction;
  - *Faults*
    - Unintentional;
    - Ex: page faults (recoverable), protection faults (unrecoverable)
      (you could see this in the form of a seg fault if you are trying
      to dereference ~NULL~), floating point exceptions (if you divide
      or mod by 0 that causes of floating point exception).
    - Either re-executes faulting (``current'') instruction or aborts.
  - *Aborts*
    - Unintentional and unrecoverable
    - examples: parity error (e.g., RAM gets corrupted), machine check
    - Aborts current program

- What is a *program*?
  - A bunch of data and instructions stored in an executable binary
    file;
  - Written according to a specification that tells users what it is
    supposed to do (ELF, in the case of Linux);
  - Stateless since binary file is static;

- A *process* is an instance of a running program
  - A process provides each program with two key abstractions
    - Logical control flow
      - Each program seems to have exclusive use of the CPU
    - Private virtual address space
      - Each program seems to have exclusive use of the main memory
      - Gives the running program a *state*.

- How are these illusions maintained?
  - Process executions interleaved (multitasking) or run on separate
    cores
  - Address spaces managed by virtual memory system
    - just know that this exists for now; we'll talk about it soon.

- Processes
  - Four basice states
    - Running
      - Executing instructions on the CPU
      - Number bounded by number of CPU cores
    - Runnable
      - Waiting to be running
    - Blocked
      - Waiting for an event, maybe input from STDIN
      - Not runnable
    - Zombie
      - Terminated, not yet reaped

- Four basic process control function families:
  - ~fork()~
  - ~exec()~
    - and other variants such as ~execvel()~
  - ~exit()~
  - ~wait()~
    - and variants like ~waitpid()~

- ~int fork(void)~
  - creates a new process (child process) that is idential to the
    calling process (parent process)
  - OS creates an exact ducplicat of parent's state:
    - Virtual address space (memory), including heap and stack
    - Registers, except for the return value (%eax/%rax)
    - File descriptors but files are shared
  - Result -> Equal but separate state
  - Fork is interesting (and often confusing) because it is called
    once but returns twice.
  - returns 0 to the child process
  - returns child's pid to the parent process
  - usually used like:
    #+begin_src C
      pid_t pid = fork();

      if (pid == 0) {
          // pid is 0 so we can detect child
          printf("hello from child\n");
      }

      else {
          // pid = child's assigned pid
          printf("hello from parent\n");
      }
    #+end_src

- ~int exec()~
  - replaces the current process's state and context
    - but keeps PID, open files, and signal context
  - Provides a way to load and run *another* program
    - replaces the current running memory image with that of new
      program
    - Set up stack with arguments and environments variables
    - Start execution and the entry point
  - Never returns on successful execution
  - The newly loaded program's perspective: as if the previous program
    has not been run before
  - More useful variant is ~int execve()~
  - For details? man 3 exec

- ~void exit(int status)~
  - Normally return with a status 0 (other numbers indicate an error)
  - Terminates the current process
  - OS frees resources such as heap memory and open file descriptors
    and so on
  - Reduces to a zombie state
    - Must wait to be reaped by the parent process (or the init
      process if the parent died)
    - Signal is sent to the parent process notifying of death
    - Reaper can inspect the exist status

- ~int wait(int *child_status)~
  - suspends current process until one of its children terminates
  - return value is the pid of the child process that terminated
    - When wait returns a pid > 0, child process has been reaped
    - All child resources freed
  - if ~child_status != NULL~, then the object it points to will be
    set to a status indicating why the child process terminated
  - More useful variants is ~int waitpid()~
  - For details: man 2 wait

- A *signal* is a small message that notifies a process that an event
  of some type has occurred in the system
  - akin to exceptions and interrupts (asynchronous)
  - set from the kernel (sometimes at the request of another process)
    to a proces
  - signal type is identified by small integer ID's (1-30)
  - only information in a signal is its ID and the fact that it
    arrived

    | ID | Name    | Default Action   | Corresponding Event                      |
    |----+---------+------------------+------------------------------------------|
    |  2 | SIGINT  | Terminate        | Interrupt (e.g., ctl-c from keyboard)    |
    |----+---------+------------------+------------------------------------------|
    |  9 | SIGKILL | Terminate        | Kill program (cannot override or ignore) |
    |----+---------+------------------+------------------------------------------|
    | 11 | SIGSEGV | Terminate & Dump | Segmentation violation                   |
    |----+---------+------------------+------------------------------------------|
    | 14 | SIGALRM | Terminate        | Time signal                              |
    |----+---------+------------------+------------------------------------------|
    | 17 | SIGCHLD | Ignore           | Child stopped or terminated              |

- Kernel *sends* (delivers) a signal to a /destination process/ by
  updating some state in the context of the destination process.

- Kernel sends a signal for one of the following reasons:
  - Kernel as detected a system event such as Ctrl-C (SIGINT),
    divide-by-zero (SIGFPE), or the termination of a child process
    (SIGCHLD)
  - Another program called the kill() function
  - The user a kill utility

- A destination process *receives* a signal when it ii forced by the
  kernel to react in some way to the delivery of the signla

- Receiving a signal is non-queuing
  - There is only one bit in the context per signal
  - Receving 1 or 300 SIGINTs looks the same to the process

- Signals are recevied at the context switch

- Three possible ways to react:
  - ignore
  - terminate the process (with optional core dump)
  - catch the signal by executing a user-leve function called signal
    handler
    - akin to a hardware exception handler being called in response to
      an asynchronous interrupt

- Blocking signals
  - Sometimes code needs to run through a section that can't be
    interrupsed
  - implemented with ~sigprocmask()~

- Waiting for signals
  - Sometimes, we want to pause execution until we get a specific
    signal
  - Implemented with ~sigsuspend()~

- Can't modify behavior of SIGKILL and SIGSTOP

- signal handlers
  - can be installed to run when a signal is received
  - The form is ~void handler(int signum) { }~
  - Separate flow of control in the same process
  - Resumes normal flow of control upon returning
  - Can be called anytime when the appropriate signal is fired

- ~int sigsuspend(const signset_t *mask)~
  - Can't use ~wait()~ twice --- use sigsuspend!
  - Temporarily replaces the signal mask of the calling process with
    the mask given
  - Suspends the process until delivery of a signal whose action is to
    invoke a signal handler or terminate a process
  - Returns if the signal is caught
    - Signal mask restored to the previous state
  - Use ~sigaddset()~, ~sigemptyset()~, et. to create the mask.

- Every process belongs to exactly one process group
- Process groups can be used to distribute signals easily
- A forked process becomes a member of the parent's process group

- ~add_job~...

- ~remove_job~...

** shell lab
- read the code you are given
- don't be afraid to write your own helper functions
- read man pages:
  - sigemptyset()
  - sigaddset()
  - sigprocmask()
  - sigsuspend()
  - waitpid()
  - open()
  - dup2()
  - setpgid()
  - kill()

- don't use sleep() to solve synchronization issues

- hazards
  - Race conditions
    - hard to debug so start early (and think carefully)
  - Reaping zombies
    - Race conditions
    - Handling signals correctly
  - waiting for foreground job
    - Think carefull about what the right way to do this is

- Run your shell...

* Network Programming
** Practice Problem 11.1
Complete the following table:

| Hex address | Dotted-decimal address |
|-------------+------------------------|
|         0x0 |                0.0.0.0 |
|-------------+------------------------|
|  0xffffffff |        255.255.255.255 |
|-------------+------------------------|
|  0x7f000001 |              127.0.0.1 |
|-------------+------------------------|
|  0xcdbca079 |        205.188.160.121 |
|-------------+------------------------|
|  0x400c950d |           64.12.149.13 |
|-------------+------------------------|
|  0xcdbc9217 |         205.188.146.23 |

** Practice Problem 11.2
#+begin_quote
Write a program ~hex2dd.c~ that converts its hex argument to a
dotted-decimal string and prints the result. For example:

#+begin_src bash
  linux> ./hex2dd 0x8002c2f2
  128.2.194.242
#+end_src
#+end_quote

#+begin_src C
  /*
    Covert hex argument to a dotted-decimal string and print it.

    (Practice problem 11.2)
  */

  #include <stdint.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <arpa/inet.h>

  #define MAXBUF 100

  int main(int argc, char* argv[]) {

      struct in_addr inaddr; /* Address in network byte order (big endian)*/
      uint32_t addr;         /* Address in host byter order */
      char buf[MAXBUF];      /* Buffer for dotted-decimal string */

      if (argc != 2) {
          fprintf(stderr, "usage: %s <hex number>\n", argv[0]);
          exit(0);
      }
      sscanf(argv[1], "%x", &addr); // scan input

      inaddr.s_addr = htonl(addr); // convert input into network order
                                   // and store it in to in_addr structure

      if (!inet_ntop(AF_INET, &inaddr, buf, MAXBUF)) { // convert to dotted-decimal
          printf("error: inet_ntop\n");
          exit(1);
      }
      printf("%s\n", buf);

      return 0;
  }
#+end_src

** Practice Problem 11.3
#+begin_quote
Write a program ~dd2hex.c~  that converts its dotted-decimal argument
to a hex number and prints the result. For example,

#+begin_src bash
  linux> ./dd2hex 128.2.194.242
  0x8002c2f2
#+end_src
#+end_quote

#+begin_src C
  /*
    Convert dotted-decimal argument to a hex number and print it.

    (Practice problem 11.3)
  */

  #include <arpa/inet.h>
  #include <netinet/in.h>
  #include <stdint.h>
  #include <stdio.h>
  #include <stdlib.h>

  #define MAXBUF 100

  int main(int argc, char *argv[]) {
      if (argc != 2) {
          fprintf(stderr, "usage: %s <dotted-decimal value>\n", argv[0]);
          exit(0);
      }

      struct in_addr inaddr; /* Address in network bite order (big endian) */

      if (!inet_pton(AF_INET, argv[1], &inaddr)) {
          printf("error: inet_pton\n");
          exit(1);

      }

      uint32_t addr = ntohl(inaddr.s_addr); // address in host order

      printf("0x%x\n", addr);

      return 0;
  }
#+end_src

** 11.4.8 Helper Functions for the Socket Interface
The function ~open_clientfd~ can be called by a client to establish a
connection with a server.

#+begin_src C
  int open_clientfd(char *hostname, char *port) {
      int clientfd;
      struct addrinfo hints, *listp, *p;

      /* Get a list of potential server addresses */
      memset(&hints, 0, sizeof(struct addrinfo));
      hints.ai_socktype = SOCK_STREAM; /* Open a connection */
      hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
      hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */
      Getaddrinfo(hostname, port, &hints, &listp);

      /* Walk the list for one that we can successfully connect to */
      for (p = listp; p; p = p->ai_next) {
          /* Create a socket descriptor */
          if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
              continue; /* Socket failed, trye the next */

          /* Connect to the server */
          if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
              break; /* Success */
          Close(clientfd); /* Connect failed, try another */
      }

      /* Clean up */
      Freeaddrinfo(listp);
      if (!p) /* All connects failes */
          return -1;
      else /* the last connect succeded */
          return clientfd;
  }
#+end_src

The function ~open_listenfd~ can be called by a server to create a
listening descriptor that is ready to receive connection requests.

#+begin_src C
  int open_listenfd(char *port) {
      struct addrinfo hints, *listp, *p;
      int listenfd, optval=1;

      /* Get a list of potential server addresses */
      memset(&hints, 0, sizeof(struct addrinfo));
      hints.ai_socktype = SOCK_STREAM; /* Accepts connections */
      hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */
      hints.ai_flags |= AI_NUMERICSERV;
      Getaddrinfo(NULL, port, &hints, &listp);

      /* Walk the list for one that we can bind to */
      for (p = listp; p; p = p->ai_next) {
          /* Create socket descriptor */
          if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
              continue; /* Socket failed, try the next */

          /* Eliminates "Address already in use" error from bing */
          Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
                     (const void *)&optval, sizeof(int));

          /* Bind the descriptor to the address */
          if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
              break;
          Close(listenfd); /* Bind failed, try the next */
      }

      /* Clean up */
      Freeaddrinfo(listp);
      if (!p) /* No address worked */
          return -1;

      /* Make it a listening socket read to accept connection requests */
      if (listen(listenfd, LISTENQ) < 0) {
          Close(listenfd);
          return -1;
      }
      return listenfd;
  }
#+end_src
